# coding: utf-8

"""
    @calcom/api: Public API for Cal.com

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from typing import Any, ClassVar, Dict, List, Optional, Union
from pydantic import BaseModel, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from pydantic import Field
from openapi_client.models.add_event_type_request_hosts_inner import AddEventTypeRequestHostsInner
from openapi_client.models.add_event_type_request_locations_inner_inner import AddEventTypeRequestLocationsInnerInner
from openapi_client.models.add_event_type_request_recurring_event import AddEventTypeRequestRecurringEvent
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class EditEventTypeByIdRequest(BaseModel):
    """
    EditEventTypeByIdRequest
    """ # noqa: E501
    length: Optional[StrictInt] = Field(default=None, description="Duration of the event type in minutes")
    metadata: Optional[Dict[str, Any]] = Field(default=None, description="Metadata relating to event type. Pass {} if empty")
    title: Optional[StrictStr] = Field(default=None, description="Title of the event type")
    slug: Optional[StrictStr] = Field(default=None, description="Unique slug for the event type")
    schedule_id: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The ID of the schedule for this event type", alias="scheduleId")
    hosts: Optional[List[AddEventTypeRequestHostsInner]] = None
    hidden: Optional[StrictBool] = Field(default=None, description="If the event type should be hidden from your public booking page")
    position: Optional[StrictInt] = Field(default=None, description="The position of the event type on the public booking page")
    team_id: Optional[StrictInt] = Field(default=None, description="Team ID if the event type should belong to a team", alias="teamId")
    period_type: Optional[StrictStr] = Field(default=None, description="To decide how far into the future an invitee can book an event with you", alias="periodType")
    period_start_date: Optional[datetime] = Field(default=None, description="Start date of bookable period (Required if periodType is 'range')", alias="periodStartDate")
    period_end_date: Optional[datetime] = Field(default=None, description="End date of bookable period (Required if periodType is 'range')", alias="periodEndDate")
    period_days: Optional[StrictInt] = Field(default=None, description="Number of bookable days (Required if periodType is rolling)", alias="periodDays")
    period_count_calendar_days: Optional[StrictBool] = Field(default=None, description="If calendar days should be counted for period days", alias="periodCountCalendarDays")
    requires_confirmation: Optional[StrictBool] = Field(default=None, description="If the event type should require your confirmation before completing the booking", alias="requiresConfirmation")
    recurring_event: Optional[AddEventTypeRequestRecurringEvent] = Field(default=None, alias="recurringEvent")
    disable_guests: Optional[StrictBool] = Field(default=None, description="If the event type should disable adding guests to the booking", alias="disableGuests")
    hide_calendar_notes: Optional[StrictBool] = Field(default=None, description="If the calendar notes should be hidden from the booking", alias="hideCalendarNotes")
    minimum_booking_notice: Optional[StrictInt] = Field(default=None, description="Minimum time in minutes before the event is bookable", alias="minimumBookingNotice")
    before_event_buffer: Optional[StrictInt] = Field(default=None, description="Number of minutes of buffer time before a Cal Event", alias="beforeEventBuffer")
    after_event_buffer: Optional[StrictInt] = Field(default=None, description="Number of minutes of buffer time after a Cal Event", alias="afterEventBuffer")
    scheduling_type: Optional[StrictStr] = Field(default=None, description="The type of scheduling if a Team event. Required for team events only", alias="schedulingType")
    price: Optional[StrictInt] = Field(default=None, description="Price of the event type booking")
    currency: Optional[StrictStr] = Field(default=None, description="Currency acronym. Eg- usd, eur, gbp, etc.")
    slot_interval: Optional[StrictInt] = Field(default=None, description="The intervals of available bookable slots in minutes", alias="slotInterval")
    success_redirect_url: Optional[StrictStr] = Field(default=None, description="A valid URL where the booker will redirect to, once the booking is completed successfully", alias="successRedirectUrl")
    description: Optional[StrictStr] = Field(default=None, description="Description of the event type")
    seats_per_time_slot: Optional[StrictInt] = Field(default=None, description="The number of seats for each time slot", alias="seatsPerTimeSlot")
    seats_show_attendees: Optional[StrictBool] = Field(default=None, description="Share Attendee information in seats", alias="seatsShowAttendees")
    seats_show_availability_count: Optional[StrictBool] = Field(default=None, description="Show the number of available seats", alias="seatsShowAvailabilityCount")
    locations: Optional[List[List[AddEventTypeRequestLocationsInnerInner]]] = Field(default=None, description="A list of all available locations for the event type")
    __properties: ClassVar[List[str]] = ["length", "metadata", "title", "slug", "scheduleId", "hosts", "hidden", "position", "teamId", "periodType", "periodStartDate", "periodEndDate", "periodDays", "periodCountCalendarDays", "requiresConfirmation", "recurringEvent", "disableGuests", "hideCalendarNotes", "minimumBookingNotice", "beforeEventBuffer", "afterEventBuffer", "schedulingType", "price", "currency", "slotInterval", "successRedirectUrl", "description", "seatsPerTimeSlot", "seatsShowAttendees", "seatsShowAvailabilityCount", "locations"]

    @field_validator('period_type')
    def period_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('UNLIMITED', 'ROLLING', 'RANGE'):
            raise ValueError("must be one of enum values ('UNLIMITED', 'ROLLING', 'RANGE')")
        return value

    @field_validator('scheduling_type')
    def scheduling_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('ROUND_ROBIN', 'COLLECTIVE'):
            raise ValueError("must be one of enum values ('ROUND_ROBIN', 'COLLECTIVE')")
        return value

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True,
        "protected_namespaces": (),
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of EditEventTypeByIdRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in hosts (list)
        _items = []
        if self.hosts:
            for _item in self.hosts:
                if _item:
                    _items.append(_item.to_dict())
            _dict['hosts'] = _items
        # override the default output from pydantic by calling `to_dict()` of recurring_event
        if self.recurring_event:
            _dict['recurringEvent'] = self.recurring_event.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in locations (list of list)
        _items = []
        if self.locations:
            for _item in self.locations:
                if _item:
                    _items.append(
                         [_inner_item.to_dict() for _inner_item in _item if _inner_item is not None]
                    )
            _dict['locations'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of EditEventTypeByIdRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "length": obj.get("length"),
            "metadata": obj.get("metadata"),
            "title": obj.get("title"),
            "slug": obj.get("slug"),
            "scheduleId": obj.get("scheduleId"),
            "hosts": [AddEventTypeRequestHostsInner.from_dict(_item) for _item in obj.get("hosts")] if obj.get("hosts") is not None else None,
            "hidden": obj.get("hidden"),
            "position": obj.get("position"),
            "teamId": obj.get("teamId"),
            "periodType": obj.get("periodType"),
            "periodStartDate": obj.get("periodStartDate"),
            "periodEndDate": obj.get("periodEndDate"),
            "periodDays": obj.get("periodDays"),
            "periodCountCalendarDays": obj.get("periodCountCalendarDays"),
            "requiresConfirmation": obj.get("requiresConfirmation"),
            "recurringEvent": AddEventTypeRequestRecurringEvent.from_dict(obj.get("recurringEvent")) if obj.get("recurringEvent") is not None else None,
            "disableGuests": obj.get("disableGuests"),
            "hideCalendarNotes": obj.get("hideCalendarNotes"),
            "minimumBookingNotice": obj.get("minimumBookingNotice"),
            "beforeEventBuffer": obj.get("beforeEventBuffer"),
            "afterEventBuffer": obj.get("afterEventBuffer"),
            "schedulingType": obj.get("schedulingType"),
            "price": obj.get("price"),
            "currency": obj.get("currency"),
            "slotInterval": obj.get("slotInterval"),
            "successRedirectUrl": obj.get("successRedirectUrl"),
            "description": obj.get("description"),
            "seatsPerTimeSlot": obj.get("seatsPerTimeSlot"),
            "seatsShowAttendees": obj.get("seatsShowAttendees"),
            "seatsShowAvailabilityCount": obj.get("seatsShowAvailabilityCount"),
            "locations": [
                    [AddEventTypeRequestLocationsInnerInner.from_dict(_inner_item) for _inner_item in _item]
                    for _item in obj.get("locations")
                ] if obj.get("locations") is not None else None
        })
        return _obj


